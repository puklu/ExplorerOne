#include "common/assertHandler.hpp"
#include "common/registerArrays.hpp"
#include "drivers/interfaces/pinBank.hpp"
#include "ExtiPin.hpp"


ExtiPin::ExtiPin(const ExtiPinInitStruct &pin_init_struct)
    : PinBase(pin_init_struct.pin_name)
{
    mPinName = pin_init_struct.pin_name;
    Enable();
    mIsInitialized = true;
 }


/**
For the external interrupt lines, to generate the interrupt, the interrupt line should be
configured and enabled. This is done by programming the two trigger registers with the
desired edge detection and by enabling the interrupt request by writing a ‘1’ to the
corresponding bit in the interrupt mask register. When the selected edge occurs on the
external interrupt line, an interrupt request is generated. The pending bit corresponding to
the interrupt line is also set. This request is reset by writing a 1 in the pending register.
For the internal interrupt lines, the active edge is always the rising edge. The interrupt is
enabled by default in the interrupt mask register and there is no corresponding pending bit
in the pending register.
For the external lines, an interrupt/event request can also be generated by software by
writing a 1 in the software interrupt/event register.

To configure a line as interrupt source, use the following procedure:
- Configure the corresponding mask bit in the EXTI_IMR register.
- Configure the Trigger Selection bits of the Interrupt line (EXTI_RTSR and EXTI_FTSR)
- Configure the enable and mask bits that control the NVIC IRQ channel mapped to the
EXTI so that an interrupt coming from one of the EXTI lines can be correctly
acknowledged.

Any of the external lines can be configured as software interrupt/event lines. The following is
the procedure to generate a software interrupt.
- Configure the corresponding mask bit (EXTI_IMR, EXTI_EMR)
- Set the required bit of the software interrupt register (EXTI_SWIER)
*/
void ExtiPin::EnableInterrupt(InterruptCallback cb)
{
    // Make sure that the pin exists in the pinBank before moving ahead
    ASSERT(activePins[mPortNumber][mPinNumber] != nullptr);

    ASSERT(cb != nullptr);
    mInterruptCallbackFunction = cb;

    // Enable system configuration
    mpRCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
 
    // // Map the GPIO pin to EXTI line
    mpSystemConfigController->EXTICR[mPinNumber / 4] |= IO::aSyscfgExtiRegisterBits[mPinNumber];
    mpSystemConfigController->EXTICR[mPinNumber / 4] &= (mPortNumber << (4* (mPinNumber % 4)));


    // Unmask the Interrupt mask register bit for the EXTI line. EXTI line number
    // corresponds to the pin number so this works out
    mpInterruptController->IMR |= (1<<mPinNumber);

    mIrqNumber = GetIRQn();

    EnableNVIC(); 
}


void ExtiPin::DisableInterrupt(){
    mpInterruptController->IMR &= ~(1<<mPinNumber);
    NVIC_DisableIRQ(mIrqNumber);
}

void ExtiPin::EnableNVIC(){
    NVIC_EnableIRQ(mIrqNumber);

    // Set priority
    NVIC_SetPriority(mIrqNumber, 2);

  }

bool ExtiPin::isInterruptPresent() const {
    return (mpInterruptController->PR & (1<<mPinNumber));
}  

void ExtiPin::ClearInterrupt(){
    if(isInterruptPresent())
    {
        mpInterruptController->PR |= (1<<mPinNumber);
    }
}  

IRQn_Type ExtiPin::GetIRQn() const{
    return IO::aExtiIrqNumbers[mPinNumber]; 
}

InterruptCallback ExtiPin::GetInterruptCallback(){
    return mInterruptCallbackFunction;
}

void ExtiPin::SelectInterruptTrigger(IO::eTriggerEdge edge){
    // TODO: add assert
    switch (edge)
    {
    case IO::eTriggerEdge::IO_INTERRUPT_TRIGGER_RISING_EDGE:
        mpInterruptController->RTSR |= (1 << mPinNumber);
        break;

    case IO::eTriggerEdge::IO_INTERRUPT_TRIGGER_FALLING_EDGE:
        mpInterruptController->FTSR |= (1 << mPinNumber);
        break;

    case IO::eTriggerEdge::IO_INTERRUPT_TRIGGER_BOTH_EDGE:
        mpInterruptController->RTSR |= (1 << mPinNumber);
        mpInterruptController->FTSR |= (1 << mPinNumber);
        break;      
    default:
        ASSERT(0);
        break;
    } 
}
